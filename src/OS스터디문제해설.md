### 📌 1주차 스터디 문제해설
***
#### < 제작 문제 >
#### 1번 해설
커널의 역할 
1) 프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경을 제공한다.
2) 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리 공간보다 큰 가상공간을 제공한다.
3) 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스를 제공한다. 
4) 입출력 관리 : 필요한 입력과 출력 서비스를 제공한다.
5) 프로세스 간 통신 관리 : 공동 작업을 위한 프로세스간 통신 환경을 제공한다.

#### 2번 해설
부팅의 과정은 다음과 같다. 
<br>
(1) BIOS : 컴퓨터의 전원을 키면, 가장 먼저 ROM에 있는 BIOS가 실행된다.
<br>
(2) POST(Power Of Self Test) : BIOS는 POST(Power On Self Test)를 실행하여 주요 하드웨어가 정상적으로 동작하는지 확인한다.
<br>
(3) 부트스트랩(BootStrap) : POST에 이상이 없으면 BIOS는 부트스트랩(Bootstrap)을 실행하여 부팅 정보를 메모리로 가져온다.
<br>
(하드디스크의 마스텉 부트 레코드에 저장된 부트스트랩을 메모리로 가져와 실행시킨다고 해도 됨!)
<br>
(4) 부트로더(BootLoader) : 부트로더는 디스크의 운영체제 코드를 메모리로 가져온다. 
<br>
(5) 운영체제(OS) 실행 : 읽어온 운영체제 코드에 의해 CPU는 첫 프로세스(Demon)을 실행한다.
<br></br>

#### 3번 해설
1) 캐시는 문제에서 언급한대로, 속도가 빠른 장치와 느린 장치 사이에서 일어나는 병목 현상을 해결하기 위한 방법이다.
   이러한 캐시를 이용하여 컴퓨터 성능을 향상시키려면 CPU에서 어떤 데이터를 사용할 것인지 예측할 수 있어야 하며, 예측이 들어맞는 정도를 "캐시적중률"이라 한다.
   이러한 캐시 적중률이 높아야 한다는 조건이 선행되어야 CPU에서 실제로 사용하는 자원을 캐시에서 많이 가져다 사용할 수 있다.
   <br></br>

2) 캐시 적중률을 높이는 방법은 두 가지가 존재하는데, 캐시의 크기를 늘리거나 데이터를 가져오는 것이다.
   그 중 데이터를 가져오는데에 데이터 "지역성의 원리"가 사용된다.
   프로그램은 모든 코드나 데이터에 균등하게 엑세스하지 않는다는 특성을 가지고 있다.
   "지역성의 원리"란 이러한 프로그램의 특성을 전제로 모든 코드에 균등하게 접근하지 않고, 어느 한 순간에 집중적으로 특정 부분을 집중적으로 참조하는 특성이다.
   지역성(Locality)은 시간 지역성과 공간 지역성으로 나뉜다.
   <br></br>
   시간 지역성은 최근에 참조된 내용은 곧 다음에 다시 참조되는 특성을 의미한다.
   <br></br>
   공간 지역성은 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성을 의미한다.
   <br></br>
   이러한 지역성을 이용하여 캐시는 원하는 데이터를 메모리에서 가져올 수 있고, 캐시 적중률을 높일 수 있다.

#### 4번 해설
인터럽트는 초기의 컴퓨터 시스템의 폴링 방식을 해결하기 위해 등장하였다. 
폴링 방식은 CPU가 직접 입출력장치에서 데이터를 가져오거나 내보내는 방식인데, 본래의 역할 외에 모든 입출력에 관여해야했기에 작업 효율이 떨어질 수 밖에 없었다.
인터럽트는 기존의 비효율적인 방식을 CPU의 본래 작업과 저장장치의 데이터 이동을 분리함으로써 시스템의 효율을 높힌 방식을 말한다.
또한 인터럽트는 입출력 관리자가 CPU에 보내는 완료신호를 의미하기도 한다. 
인터럽트가 발생하면, 하던 작업을 중단하고 옮겨진 데이터를 처리해야 한다.

<br>
예시1) 인터럽트는 사용자가 사용중이던 PC를 강제종료하는 경우 발생한다. 
작업 중이던 PC는 인터럽트가 발생하자마자 하던 작업을 모두 멈추고 처리 중인 데이터를 안전하게 보관한 뒤 시스템을 종료해야 한다.

<br>
예시2 ) 사용자 작업으로 인해 운영체제의 작업이 중단된 경우에 사용자 작업이 할당된 메모리의 범위에서 벗어난다면, 인터럽트가 발생한다. 
인터럽트가 발생한 즉시 CPU는 운영체제를 호출하여 문제를 처리하게 시키고, 운영체제는 해당 프로그램을 강제종료 시킨다. 

#### 5번 해설
멀티 프로세스는 컴퓨터의 성능을 높이기 위해 프로세서를 여러개 설치하여 사용하는 방법이다. 
여러개의 프로세스를 사용하기 때문에 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세서들이 있기 때문에 작업에 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있다.
하지만, 멀티 스레드 보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점을 갖고 있다. 
<br>
멀티 스레드는 하나의 코어 내에서 여러개의 명령어를 처리하는 방식을 의미한다. 
스레드란 CPU가 처리할 수 있는 작업의 단위인데, 여러개의 스레드를 동시에 처리하여 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 
오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다.

***
### 🔥2주차 문제해설
#### < 제작 문제 >
#### 1. 프로세스의 설명 중 틀린 것은?
정답 : ③
<br>
① 프로그램은 어떤 데이터를 사용하여 어떤 작업을 할지 그 절차를 적어놓은 것으로, 저장장치에 저장된 정적인 상태이다.
반면, 프로세스는 프로그램으로 작성된 절차를 실행으로 옮긴다는 의미로, 실행을 위해 메모리에 올라온 동적인 상태를 의미한다.
<br>
② 프로세스가 종료되면 메모리 영역에서 삭제되고, 프로세스 제어 블록도 폐기된다. 
그래서 프로세스 제어 블록의 추가는 프로그램이 프로세스가 되는 과정을, 프로세스 제어 블록의 폐기는 프로세스가 프로그램이 되는 것임을 의미한다.  
<br>
**③ 프로그램을 프로세스로 전환하려면, 프로세스 제어 블록(PCB)를 받아와야하지만, 메모리로부터 받아오는 것이 아니라 운영체제로부터 받아와야한다.**
<br>
④ 컴퓨터 내에는 사용자가 실행한 프로세스만 있는 것이 아니다. 
운영체제도 프로그램이기 때문에 프로세스의 형태로 실행된다.
따라서 컴퓨터에서 사용자 프로세스와 운영체제가 섞여서 실행된다.
<br>
⑤ 한 번에 하나의 작업만 처리하는 일괄 작업 방식보다 시간을 배분하여 여러 개의 작업을 나누어 처리하는 시분할 방식이 더 효과적이다.
<br>
#### 2. 프로세스의 상태에 대한 설명으로 틀린 것은?
정답 : ②
<br>
① 완료 상태에서 오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제 종료를 만나면 디버깅하기 위해 강제종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프라고 한다.
<br>
② **기존의 프로세스는 4가지 상태가 존재하였는데, 운영체제의 효율성을 고려하여 대기 상태를 만들었다.
원래 인터럽트 시스템에서 프로세스가 입출력을 요구하면 CPU가 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다. 
이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없었는데, 이때 발생하는 비효율성때문에 대기 상태를 만들어 
입출력을 요구한 프로세스가 입출력을 완료할 때까지 기다리게 하여 운영체제의 효율성을 향상시켰다.**
<br>
③ CPU 스케줄러에 의해 선택된 프로세스는 실행 상태에서 일정 시간 동안 작업을 하는데, 프로세스에게 배당된 작업 시간을 타임 슬라이스 또는 타임 퀸텀이라 한다. 
<br>
④ 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일을 CPU스케줄러가 수행한다. 
CPU 스케줄러는 준비 상태의 맨 앞에서 기다리고 있는 프로세스의 제어블록을 CPU에 전달하여 작업이 이루어지게 한다. 
이렇게 준비 상태에 있는 프로세스를 골라 실행 상태로 바꾸는 CPU스케줄러의 작업을 디스패치(dispatch)라고 한다. 
<br>
⑤ 대기 상태는 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태로 Wait status라 한다. 
대기 상태에서 프로세스는 입출력장치별로 마련된 큐에서 기다린다. 입출력이 완료되면 인터럽트가 발생하고, 찾아낸 프로세스의 프로세스 제어 블록을 준비 상태로 이동시킨다. 
이렇게 어떤 프로세스가 대기 상태에서 준비 상태로 이동하는 것은 인터럽트 때문이다.  
<br>
#### 3. 프로세스의 생성과 복사에 대한 다음 설명 중 맞는 것은?
정답 : ④
<br>
① fork() 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수로 **커널**에서 제공한다.
<br>
② fork() 시스템 호출을 하면 프로세스 제어 블록 중 프로세스 구분자(PID)와 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)가 바뀌며,
**프로세스를 복사했어도 엄연히 다른 프로세스이기 때문에 부모 프로세스와 자식 프로세스가 차지하는 메모리의 위치가 다르기 때문에 메모리 관련 정보 또한 함께 바뀐다.**
<br>
③ exec() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수이다. 하지만 **부모-자식 프로세스의 관계가 끊어지지 않으며 프로세스는 그대로 둔 채, 프로세스의 내용만 새로 재구성 되는 것이다.**
<br>
④ exec() 시스템 호출을 하면 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 리셋된다.
<br>
⑤ exec() 시스템 호출을 하면 데이터 영역이 새로 채워지고 스택 영역이 리셋되지만, **부모-자식 프로세스 관계가 끊어지는 것은 아니기 때문에 PID, PPID, CPID가 바뀌지는 않는다.** 
<br>
#### 4. 객관식
① 운영체제 입장의 작업 단위는 프로세스이고 CPU 입장의 작업 단위는 스레드이다.
<br>
② 멀티스레드는 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영기법이다.
<br>
③ **CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경과 CPU 내 여러 개의 코어에 스레드를 배정하여 동시에 작동하는 것 모두 멀티 프로세싱이다.**
<br>
④ 하나의 CPU에서 여러 스레드를 동시에 처리하는 것을 CPU 멀티스레드라고 부른다.
<br>
⑤ 스레드는 멀티태스킹의 낭비 요소를 제거하기 위해 사용된다.
<br>
#### 5. 객관식
정답 : ⑤
<br>
① 멀티스레드를 사용하여 여러 개의 스레드를 동시에 실행시키면 첫번째 작업은 천천히 실행되지만 두번째 작업부터 빠르게 실행된다.
<br>
② 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다.
<br>
③ 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있다.
<br>
④ 효울성 향상 : 여러 개의 프로세스를 생성할 필요가 없이 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다.
<br>
⑤ 다중 CPU 지원 : 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU의 **사용량이** 증가하고 프로세스의 처리 시간이 단축된다.
<br>

#### 6. 보류상태가 되는 경우 3가지 이상 서술
- **메모리가 꽉 차서** 일부 프로세스를 메모리 밖으로 내보낼 때
- **프로그램에 오류**가 있어서 실행을 미루어야 할 때
- **바이러스**와 같이 악의적인 공격을 하는 프로세스라고 판단할 때
- **매우 긴 주기로 반복되는 프로세스**라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 **프로세스의 입출력이 계속 지연**될 때

cf) 보류 상태는 스왑 영역에 있는 상태를 의미하고, 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태이다. 

#### 7. 문맥 교환이란 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이러한 문맥교환을 활용하여, 다음의 문제를 해결해보자. 20초의 길이를 가진 비디오플레이어와 15초의 시간할당량을 가진 PPT가 동시에 실행된다고 가정해보자. 이러한 경우 문맥교환은 몇 번 일어나는가?
정답 : 10회 
<br>
해설 : 타임 슬라이스가 3초이므로 3초를 주기로 비디오 플레이어의 작업과 PPT 작업이 번갈아가며 수행될 것이다. 
비디오 플레이어가 먼저 실행된다고 가정했을 때, 총 10번의 문맥 교환이 수행된다. 
순차적으로 문맥교환이 진행되다가 9번째 문맥교환을 끝으로, PPT작업이 종료되게 된다.
이때 PPT 작업에서 비디오 플레이어 작업으로 10번째 문맥교환을 수행하게 되고, 더 이상 문맥교환은 일어나지 않는다.
물론 남은 작업 시간이 타임 슬라이스를 초과한 5초이지만, 제어권을 넘겨줄 다른 프로세스가 없는 경우에는 커널 모드로 넘어갔다가 다시 실행되게 된다. 
따라서 위와 같은 경우 일어나는 문맥 교환은 10회이다. 

< 문맥 교환 과정 >
![](../../../Desktop/os_3.1.png)

< 한 개의 프로세스가 존재하는 경우 >
![](../../../Desktop/다운로드.png)

< 여러 개의 프로세스가 존재하는 경우 >
![](../../../Desktop/os_3.2.png)

#### 8. 멀티스레드 모델에는 3가지가 있는데, 각각의 이름와 어떻게 대응하는지 서술하시오.
멀티스레드 모델에는 사용자 스레드, 커널 스레드, 그리고 멀티레벨 스레드가 있다. 
<br>
<br>
사용자 스레드 : 커널이 멀티스레드를 지원하지 않을 때 사용하는 방법이다. 사용자 레벨에서 라이브러리를 사용하여 스레드를 구현하는데, 커널이 지원하는 스케줄링이나 동기화같은 기능을 대신 구현해준다. 
즉, 사용자 스레드는 커널 입장에서는 일반 프로세스이지만 커널이 하는 일을 라이브러리가 대신 처리하여 여러 개의 스레드로 작동한다. 
따라서 사용자 프로세스 내에 여러 개의 스레드가 존재하지만 커널의 스레드 하나와 연결되기 때문에 1 to N 모델이라 한다. 
<br>
커널 스레드 : 커널이 멀티스레드를 지원하는 방식. 하나의 사용자 스레드와 하나의 커널 스레드가 연결되기 때문에 1 to 1 모델이라 한다.
- 장점 : 멀티 CPU 사용가능 / 하나의 스레드가 대기 상태에 있어서 다른 스레드는 작업 계속할 수 있음 / 보안에 강하고 안정적으로 작동함
- 단점 : 문맥 교환 할 때 오버헤드 때문에 느리게 작동함 
<br>

멀티레벨 스레드 : 사용자 스레드 + 커널 스레드 (M to N 모델) 
- 장점 : 하나의 커널 스레드가 대기 상태에 들어가면 다른 커널 스레드가 대신 작업을 하여 시용자 스레드보다 유연하게 작업을 처리할 수 있다.
- 단점 : 문맥 교환 시 오버헤드가 있어 사용자 스레드만큼 빠르지 않음 

#### 9. 프로세스가 실행되는 동안 스택 영역과 힙 영역이 만들어지는데, 그 중 스택 영역이 갖는 특징을 2가지 서술하시오.
![](../../../Desktop/os_3.4.jpg)

- 호출한 함수가 종료되면 함수로 호출하기 전 코드로 돌아와야 하는데 되돌아올 메모리의 주소를 스택에 저장한다. 
- 스택은 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용된다. 지역변수는 함수가 호출될 때만 사용되다가 함수가 종료되면 사용한 공간을 반환해야 하는데, 지역 변수를 사용할 때 스택이 사용된다.

#### 10. 프로세스 제어 블록 (PCB)은 프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조이다. 프로세스 제어 블록의 구성요소 중 '각종 레지스터 정보', '메모리 관리 정보', '할당된 자원 정보'가 무엇인지 서술하시오.
- '각종 레지스터 정보' : 프로세스 제어 블록에는 프로세스가 실행될 때 사용하던 레지스터 (누산기, 색인 레지스터, 스택 포인터)와 같은 레지스터 값이 저장된다. 이전에 실행할 때 사용한 레지스터 값을 보관해야 다음에 실행할 수 있기 때문에 자신이 사용하던 레지스터의 중간값을 보관한다.
- '메모리 관리 정보' : 프로세스 제어 블록에는 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용되는 경계 레지스터 값과 한계 레지스터 값이 저장된다. 
- '할당된 자원 정보' : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보를 말한다. 