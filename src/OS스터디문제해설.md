### 📌 1주차 스터디 문제해설
***
#### < 제작 문제 >
#### 1번 해설
커널의 역할 
1) 프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경을 제공한다.
2) 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리 공간보다 큰 가상공간을 제공한다.
3) 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스를 제공한다. 
4) 입출력 관리 : 필요한 입력과 출력 서비스를 제공한다.
5) 프로세스 간 통신 관리 : 공동 작업을 위한 프로세스간 통신 환경을 제공한다.

#### 2번 해설
부팅의 과정은 다음과 같다. 
<br>
(1) BIOS : 컴퓨터의 전원을 키면, 가장 먼저 ROM에 있는 BIOS가 실행된다.
<br>
(2) POST(Power Of Self Test) : BIOS는 POST(Power On Self Test)를 실행하여 주요 하드웨어가 정상적으로 동작하는지 확인한다.
<br>
(3) 부트스트랩(BootStrap) : POST에 이상이 없으면 BIOS는 부트스트랩(Bootstrap)을 실행하여 부팅 정보를 메모리로 가져온다.
<br>
(하드디스크의 마스텉 부트 레코드에 저장된 부트스트랩을 메모리로 가져와 실행시킨다고 해도 됨!)
<br>
(4) 부트로더(BootLoader) : 부트로더는 디스크의 운영체제 코드를 메모리로 가져온다. 
<br>
(5) 운영체제(OS) 실행 : 읽어온 운영체제 코드에 의해 CPU는 첫 프로세스(Demon)을 실행한다.
<br></br>

#### 3번 해설
1) 캐시는 문제에서 언급한대로, 속도가 빠른 장치와 느린 장치 사이에서 일어나는 병목 현상을 해결하기 위한 방법이다.
   이러한 캐시를 이용하여 컴퓨터 성능을 향상시키려면 CPU에서 어떤 데이터를 사용할 것인지 예측할 수 있어야 하며, 예측이 들어맞는 정도를 "캐시적중률"이라 한다.
   이러한 캐시 적중률이 높아야 한다는 조건이 선행되어야 CPU에서 실제로 사용하는 자원을 캐시에서 많이 가져다 사용할 수 있다.
   <br></br>

2) 캐시 적중률을 높이는 방법은 두 가지가 존재하는데, 캐시의 크기를 늘리거나 데이터를 가져오는 것이다.
   그 중 데이터를 가져오는데에 데이터 "지역성의 원리"가 사용된다.
   프로그램은 모든 코드나 데이터에 균등하게 엑세스하지 않는다는 특성을 가지고 있다.
   "지역성의 원리"란 이러한 프로그램의 특성을 전제로 모든 코드에 균등하게 접근하지 않고, 어느 한 순간에 집중적으로 특정 부분을 집중적으로 참조하는 특성이다.
   지역성(Locality)은 시간 지역성과 공간 지역성으로 나뉜다.
   <br></br>
   시간 지역성은 최근에 참조된 내용은 곧 다음에 다시 참조되는 특성을 의미한다.
   <br></br>
   공간 지역성은 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성을 의미한다.
   <br></br>
   이러한 지역성을 이용하여 캐시는 원하는 데이터를 메모리에서 가져올 수 있고, 캐시 적중률을 높일 수 있다.

#### 4번 해설
인터럽트는 초기의 컴퓨터 시스템의 폴링 방식을 해결하기 위해 등장하였다. 
폴링 방식은 CPU가 직접 입출력장치에서 데이터를 가져오거나 내보내는 방식인데, 본래의 역할 외에 모든 입출력에 관여해야했기에 작업 효율이 떨어질 수 밖에 없었다.
인터럽트는 기존의 비효율적인 방식을 CPU의 본래 작업과 저장장치의 데이터 이동을 분리함으로써 시스템의 효율을 높힌 방식을 말한다.
또한 인터럽트는 입출력 관리자가 CPU에 보내는 완료신호를 의미하기도 한다. 
인터럽트가 발생하면, 하던 작업을 중단하고 옮겨진 데이터를 처리해야 한다.

<br>
예시1) 인터럽트는 사용자가 사용중이던 PC를 강제종료하는 경우 발생한다. 
작업 중이던 PC는 인터럽트가 발생하자마자 하던 작업을 모두 멈추고 처리 중인 데이터를 안전하게 보관한 뒤 시스템을 종료해야 한다.

<br>
예시2 ) 사용자 작업으로 인해 운영체제의 작업이 중단된 경우에 사용자 작업이 할당된 메모리의 범위에서 벗어난다면, 인터럽트가 발생한다. 
인터럽트가 발생한 즉시 CPU는 운영체제를 호출하여 문제를 처리하게 시키고, 운영체제는 해당 프로그램을 강제종료 시킨다. 

#### 5번 해설
멀티 프로세스는 컴퓨터의 성능을 높이기 위해 프로세서를 여러개 설치하여 사용하는 방법이다. 
여러개의 프로세스를 사용하기 때문에 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세서들이 있기 때문에 작업에 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있다.
하지만, 멀티 스레드 보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점을 갖고 있다. 
<br>
멀티 스레드는 하나의 코어 내에서 여러개의 명령어를 처리하는 방식을 의미한다. 
스레드란 CPU가 처리할 수 있는 작업의 단위인데, 여러개의 스레드를 동시에 처리하여 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 
오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다.

***
### 🔥2주차 문제해설
#### < 제작 문제 >
#### 1. 프로세스의 설명 중 틀린 것은?
정답 : ③
<br>
① 프로그램은 어떤 데이터를 사용하여 어떤 작업을 할지 그 절차를 적어놓은 것으로, 저장장치에 저장된 정적인 상태이다.
반면, 프로세스는 프로그램으로 작성된 절차를 실행으로 옮긴다는 의미로, 실행을 위해 메모리에 올라온 동적인 상태를 의미한다.
<br>
② 프로세스가 종료되면 메모리 영역에서 삭제되고, 프로세스 제어 블록도 폐기된다. 
그래서 프로세스 제어 블록의 추가는 프로그램이 프로세스가 되는 과정을, 프로세스 제어 블록의 폐기는 프로세스가 프로그램이 되는 것임을 의미한다.  
<br>
**③ 프로그램을 프로세스로 전환하려면, 프로세스 제어 블록(PCB)를 받아와야하지만, 메모리로부터 받아오는 것이 아니라 운영체제로부터 받아와야한다.**
<br>
④ 컴퓨터 내에는 사용자가 실행한 프로세스만 있는 것이 아니다. 
운영체제도 프로그램이기 때문에 프로세스의 형태로 실행된다.
따라서 컴퓨터에서 사용자 프로세스와 운영체제가 섞여서 실행된다.
<br>
⑤ 한 번에 하나의 작업만 처리하는 일괄 작업 방식보다 시간을 배분하여 여러 개의 작업을 나누어 처리하는 시분할 방식이 더 효과적이다.
<br>
#### 2. 프로세스의 상태에 대한 설명으로 틀린 것은?
정답 : ②
<br>
① 완료 상태에서 오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제 종료를 만나면 디버깅하기 위해 강제종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프라고 한다.
<br>
② **기존의 프로세스는 4가지 상태가 존재하였는데, 운영체제의 효율성을 고려하여 대기 상태를 만들었다.
원래 인터럽트 시스템에서 프로세스가 입출력을 요구하면 CPU가 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다. 
이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없었는데, 이때 발생하는 비효율성때문에 대기 상태를 만들어 
입출력을 요구한 프로세스가 입출력을 완료할 때까지 기다리게 하여 운영체제의 효율성을 향상시켰다.**
<br>
③ CPU 스케줄러에 의해 선택된 프로세스는 실행 상태에서 일정 시간 동안 작업을 하는데, 프로세스에게 배당된 작업 시간을 타임 슬라이스 또는 타임 퀸텀이라 한다. 
<br>
④ 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일을 CPU스케줄러가 수행한다. 
CPU 스케줄러는 준비 상태의 맨 앞에서 기다리고 있는 프로세스의 제어블록을 CPU에 전달하여 작업이 이루어지게 한다. 
이렇게 준비 상태에 있는 프로세스를 골라 실행 상태로 바꾸는 CPU스케줄러의 작업을 디스패치(dispatch)라고 한다. 
<br>
⑤ 대기 상태는 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태로 Wait status라 한다. 
대기 상태에서 프로세스는 입출력장치별로 마련된 큐에서 기다린다. 입출력이 완료되면 인터럽트가 발생하고, 찾아낸 프로세스의 프로세스 제어 블록을 준비 상태로 이동시킨다. 
이렇게 어떤 프로세스가 대기 상태에서 준비 상태로 이동하는 것은 인터럽트 때문이다.  
<br>
#### 3. 프로세스의 생성과 복사에 대한 다음 설명 중 맞는 것은?
정답 : ④
<br>
① fork() 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수로 **커널**에서 제공한다.
<br>
② fork() 시스템 호출을 하면 프로세스 제어 블록 중 프로세스 구분자(PID)와 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)가 바뀌며,
**프로세스를 복사했어도 엄연히 다른 프로세스이기 때문에 부모 프로세스와 자식 프로세스가 차지하는 메모리의 위치가 다르기 때문에 메모리 관련 정보 또한 함께 바뀐다.**
<br>
③ exec() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수이다. 하지만 **부모-자식 프로세스의 관계가 끊어지지 않으며 프로세스는 그대로 둔 채, 프로세스의 내용만 새로 재구성 되는 것이다.**
<br>
④ exec() 시스템 호출을 하면 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 리셋된다.
<br>
⑤ exec() 시스템 호출을 하면 데이터 영역이 새로 채워지고 스택 영역이 리셋되지만, **부모-자식 프로세스 관계가 끊어지는 것은 아니기 때문에 PID, PPID, CPID가 바뀌지는 않는다.** 
<br>
#### 4. 객관식
① 운영체제 입장의 작업 단위는 프로세스이고 CPU 입장의 작업 단위는 스레드이다.
<br>
② 멀티스레드는 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영기법이다.
<br>
③ **CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경과 CPU 내 여러 개의 코어에 스레드를 배정하여 동시에 작동하는 것 모두 멀티 프로세싱이다.**
<br>
④ 하나의 CPU에서 여러 스레드를 동시에 처리하는 것을 CPU 멀티스레드라고 부른다.
<br>
⑤ 스레드는 멀티태스킹의 낭비 요소를 제거하기 위해 사용된다.
<br>
#### 5. 객관식
정답 : ⑤
<br>
① 멀티스레드를 사용하여 여러 개의 스레드를 동시에 실행시키면 첫번째 작업은 천천히 실행되지만 두번째 작업부터 빠르게 실행된다.
<br>
② 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다.
<br>
③ 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있다.
<br>
④ 효울성 향상 : 여러 개의 프로세스를 생성할 필요가 없이 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다.
<br>
⑤ 다중 CPU 지원 : 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU의 **사용량이** 증가하고 프로세스의 처리 시간이 단축된다.
<br>

#### 6. 보류상태가 되는 경우 3가지 이상 서술
- **메모리가 꽉 차서** 일부 프로세스를 메모리 밖으로 내보낼 때
- **프로그램에 오류**가 있어서 실행을 미루어야 할 때
- **바이러스**와 같이 악의적인 공격을 하는 프로세스라고 판단할 때
- **매우 긴 주기로 반복되는 프로세스**라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 **프로세스의 입출력이 계속 지연**될 때

cf) 보류 상태는 스왑 영역에 있는 상태를 의미하고, 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태이다. 

#### 7. 문맥 교환이란 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이러한 문맥교환을 활용하여, 다음의 문제를 해결해보자. 20초의 길이를 가진 비디오플레이어와 15초의 시간할당량을 가진 PPT가 동시에 실행된다고 가정해보자. 이러한 경우 문맥교환은 몇 번 일어나는가?
정답 : 10회 
<br>
해설 : 타임 슬라이스가 3초이므로 3초를 주기로 비디오 플레이어의 작업과 PPT 작업이 번갈아가며 수행될 것이다. 
비디오 플레이어가 먼저 실행된다고 가정했을 때, 총 10번의 문맥 교환이 수행된다. 
순차적으로 문맥교환이 진행되다가 9번째 문맥교환을 끝으로, PPT작업이 종료되게 된다.
이때 PPT 작업에서 비디오 플레이어 작업으로 10번째 문맥교환을 수행하게 되고, 더 이상 문맥교환은 일어나지 않는다.
물론 남은 작업 시간이 타임 슬라이스를 초과한 5초이지만, 제어권을 넘겨줄 다른 프로세스가 없는 경우에는 커널 모드로 넘어갔다가 다시 실행되게 된다. 
따라서 위와 같은 경우 일어나는 문맥 교환은 10회이다. 

< 문맥 교환 과정 >
![](../../../Desktop/os_3.1.png)

< 한 개의 프로세스가 존재하는 경우 >
![](../../../Desktop/다운로드.png)

< 여러 개의 프로세스가 존재하는 경우 >
![](../../../Desktop/os_3.2.png)

#### 8. 멀티스레드 모델에는 3가지가 있는데, 각각의 이름와 어떻게 대응하는지 서술하시오.
멀티스레드 모델에는 사용자 스레드, 커널 스레드, 그리고 멀티레벨 스레드가 있다. 
<br>
<br>
사용자 스레드 : 커널이 멀티스레드를 지원하지 않을 때 사용하는 방법이다. 사용자 레벨에서 라이브러리를 사용하여 스레드를 구현하는데, 커널이 지원하는 스케줄링이나 동기화같은 기능을 대신 구현해준다. 
즉, 사용자 스레드는 커널 입장에서는 일반 프로세스이지만 커널이 하는 일을 라이브러리가 대신 처리하여 여러 개의 스레드로 작동한다. 
따라서 사용자 프로세스 내에 여러 개의 스레드가 존재하지만 커널의 스레드 하나와 연결되기 때문에 1 to N 모델이라 한다. 
<br>
커널 스레드 : 커널이 멀티스레드를 지원하는 방식. 하나의 사용자 스레드와 하나의 커널 스레드가 연결되기 때문에 1 to 1 모델이라 한다.
- 장점 : 멀티 CPU 사용가능 / 하나의 스레드가 대기 상태에 있어서 다른 스레드는 작업 계속할 수 있음 / 보안에 강하고 안정적으로 작동함
- 단점 : 문맥 교환 할 때 오버헤드 때문에 느리게 작동함 
<br>

멀티레벨 스레드 : 사용자 스레드 + 커널 스레드 (M to N 모델) 
- 장점 : 하나의 커널 스레드가 대기 상태에 들어가면 다른 커널 스레드가 대신 작업을 하여 시용자 스레드보다 유연하게 작업을 처리할 수 있다.
- 단점 : 문맥 교환 시 오버헤드가 있어 사용자 스레드만큼 빠르지 않음 

#### 9. 프로세스가 실행되는 동안 스택 영역과 힙 영역이 만들어지는데, 그 중 스택 영역이 갖는 특징을 2가지 서술하시오.
![](../../../Desktop/os_3.4.jpg)

- 호출한 함수가 종료되면 함수로 호출하기 전 코드로 돌아와야 하는데 되돌아올 메모리의 주소를 스택에 저장한다. 
- 스택은 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용된다. 지역변수는 함수가 호출될 때만 사용되다가 함수가 종료되면 사용한 공간을 반환해야 하는데, 지역 변수를 사용할 때 스택이 사용된다.

#### 10. 프로세스 제어 블록 (PCB)은 프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조이다. 프로세스 제어 블록의 구성요소 중 '각종 레지스터 정보', '메모리 관리 정보', '할당된 자원 정보'가 무엇인지 서술하시오.
- '각종 레지스터 정보' : 프로세스 제어 블록에는 프로세스가 실행될 때 사용하던 레지스터 (누산기, 색인 레지스터, 스택 포인터)와 같은 레지스터 값이 저장된다. 이전에 실행할 때 사용한 레지스터 값을 보관해야 다음에 실행할 수 있기 때문에 자신이 사용하던 레지스터의 중간값을 보관한다.
- '메모리 관리 정보' : 프로세스 제어 블록에는 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용되는 경계 레지스터 값과 한계 레지스터 값이 저장된다. 
- '할당된 자원 정보' : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보를 말한다. 

***
### 🔥3회차 문제
#### < 제작 문제 >
#### 1. 선점형 스케줄링과 비선점형 스케줄링이 각각 무엇인지 설명하고, 어떤 스케줄링 방식이 있는지 각각 2가지씩 서술하시오.
해설 : 
<br>
- 선점형 스케줄링 : 어떤 프로세스를 CPU가 할당받아 실행중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
- 종류 : 라운드로빈(RR) 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링 
- 비선점형 스케줄링 : 어떤 프로세스를 CPU가 점유하면 다른 프로세스가 이를 빼앗을 수 없는 구조
- 종류 : FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링
- 선점형 & 비선점형 둘 다 가능 : 우선순위 스케줄링
<br>

#### 2. CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태변화를 조정한다. 이때, CPU 스케줄러는 관리의 범주를 나누어 스케줄링하는데, 스케줄링의 종류를 범주에 따라 서술하시오.
해설 :
1) 고수준 스케줄링 (job scheduling) : 
메모리는 한정되어 있는데 한번에 많은 프로세스들이 올라오게 되면 대용량 메모리에 일시적으로 저장됨.
이 풀에 저장되어있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 준비 큐에 올릴 것인지 결정하는 역할 수행.
   - 시스템 내의 전체 작업의 수 조절 (어떤 작업을 시스템에서 받아들일지 거부할지 결정) 
   - 전체 시스템의 부하를 고려하여 작업을 시작할지 말지 결정 → 시스템의 전체 프로세스 수 결정 (멀티프로그래밍 정도)
   - 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 처리 작업할 때 사용
   - 메모리와 디스크 사이의 스케줄링 담당 
   - 프로세스에 메모리 할당 (admit)
   - 프로세스를 생성상태에서 준비상태로 보내는 역할
<br>

cf) 시분할 시스템에는 장기 스케줄러가 없음. 시분할 시스템에서는 프로세스가 바로 준비 상태로 올라가기 때문.

2) 중간 수준 스케줄링 (middle level scheduling) : 
고수준 스케줄링과 저수준 스케줄링 사이에서 일어나는 스케줄링 
   - 시스템의 부하를 조절하는 역할 
   - suspend와 active로 전체 시스템의 활성화된 프로세스 수 조절 (degree of multiprogramming 제어)
   - 여유 공간을 마련하기 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
<br>

3) 저수준 스케줄링 (short-term scheduling) : 
   - CPU와 메모리 사이의 스케줄링을 담당
   - 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행할지 결정 
   - 프로세스에 CPU 할당 (dispatch)
<br>
   
#### 3. SJF 스케줄링은 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU에 할당하는 비선점형 방식으로, 작은 작업을 먼저 실행하기 때문에 시스템의 효율성이 좋아진다는 장점이 있다. 하지만 이러한 장점에도 불구하고, SJF 스케줄링은 잘 사용되지 않는데 사용되지 않는 이유를 서술하고, 어떻게 해결할 수 있는지 서술하시오.
해설 :
<br>
1) 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.
   - 현재의 프로세스는 사용자와 빈번하게 상호작용하기 때문에 프로그램 종료 시간을 파악하기 어렵다. 
   - 언제 작업을 시작할지, 끝낼지 모르기 때문에 프로세스의 작업 길이를 추정하기 어렵다.
2) SJF 알고리즘은 공평성에 위배된다.
   - 실행 시간이 짧은 작업부터 하기 때문에 경우에 따라 준비 큐에 먼저 들어왔어도, 계속해서 기다려야 되는 경우가 생길 수 있다. 
   계속해서 연기되는 위와 같은 상황을 Starvation이라 하며, Starvation으로 인해 공평성이 현저히 떨어진다. 
   
- 해결방안 :
  - 프로세스의 종료 시간을 예측하기 힘든 문제는 프로세스가 자신의 작업 시간을 운영체제에 알려줌으로써 해결할 수 있다. 
  - 공평성 위배 문제는 에이징(aging)으로 완화할 수 있다

cf) 에이징(aging) : 프로세스가 양보할 수 있는 상한선을 정하는 방식 

#### 4. 인터럽트는 크게 두 가지 종류로 나뉜다. 어떤 인터럽트가 있는지, 어떤 상황에서 발생하는지 서술하시오.
해설 :
1) 동기적 인터럽트 : 프로세스가 실행 중인 명령어로 인해 발생 
   - 프로그램의 문제 때문에 발생 ( 다른 사용자의 메모리 영역에 접근 / 오버플로 & 언더플로가 발생 )
   - 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트 
   - 주변장치 조작에 의한 인터럽트 (입출력장치)
   - 산술 연산 중 발생하는 인터럽트
2) 비동기적 인터럽트 : 프로세스가 실행 중인 명령어와 무관하게 발생
   - 하드웨어 오류로 발생하는 인터럽트 (하드디스크 읽기 오류, 메모리 불량, 마우스 인터럽트, 키보드 인터럽트)
<br>
#### 5. 인터럽트 처리 과정을 설명하시오. 
해설 :
<br>
1) 인터럽트가 발생하면 **현재 실행중인 프로세스는 일시정지 상태** / **현재 프로세스 관련 정보를 임시로 저장**
2) 인터럽트 컨트롤러가 실행되어 **인터럽트의 처리 순서 결정** + 동시에 발생한 경우 우선순위 고려
3) 인터럽트 백터에 저장된 **인터럽트 핸들러 실행**
4) 핸들러가 인터럽트 처리 마치면 **일시 정지된 프로세스가 다시 실행되거나 종료** (입출력 완료 → 일시 정지된 프로세스 다시 실행 / 메모리 침범 & 오류 → 종료)

***
### 🔥4회차 해설
#### < 제작 문제 >
#### 1. 운영체제는 프로세스 간 통신을 할 수 있는 방법인 IPC를 제공한다. IPC의 방법 4가지를 말하시오.

- 1-1 : 공유 메모리 방식과 File 방식의 각각의 특징과 차이점을 서술하시오.

**< IPC의 종류 >**
1. Memory (공유 메모리와 공유 파일을 이용한 통신)
2. 파이프를 이용한 통신
3. 소켓을 이용한 통신
4. 원격 프로시저 호출을 이용한 통신 (RPC)
5. Registry(Window 한정-참고)

**<공유 메모리 방식과 File 방식의 특징>**
- 공유 메모리 방식 : OS에게 Memory 할당 받을 때 고정된 크기의 메모리 영역 받음 
- File : File 방식은 시작은 있으나 끝이 없음 (사용자가 입력하는 만큼 사이즈 증가)

#### 2. 임계구역과 관련된 전통적인 문제로 '생산자-소비자'문제가 있다. 아래의 그림을 보고 어떠한 문제가 나타날 수 있는지 서술하고( producer → consumer / consumer → producer 순서로 실행했을 때 ), 이러한 문제를 어떻게 해결할 수 있는지 서술하시오.
![](../../../Desktop/os_5.1.png)
여러 개의 프로세스 또는 스레드가 동시에 자원에 접근하게 되면 필연적으로 경쟁조건이 생겨난다.
<br>
위의 그림이 이를 단적으로 나타내고 있는데, 위에서 producer 프로세스와 consumer 프로세스가 동시에 실행되다면 문제가 발행한다. 

1. producer → consumer
<br>
만약 producer 프로세스가 미세한 시간 차로 먼저 실행되게 된다면, sum의 값이 4가 되는데, 이를 인지하지 못한 상태로 consumer 프로세스가 실행되게 되어 반영되지 않은 전역변수 3에 접근하여 sum=2라는 연산을 수행하게 된다.
<br>
결국, producer에서는 원하는 결과를 받을 수가 없는 것이다. 
<br>
2. consumer → producer
<br>
만약 consumer 프로세스가 미세한 시간 차로 먼저 실행되게 된다면, sum의 값이 2가 되는데, 이를 인지하지 못한 상태로 producer 프로세스가 실행되게 되어 반영되지 않은 전역변수 3에 접근하여 sum=4라는 연산을 수행하게 된다.
<br>
결국, consumer에서는 원하는 결과를 받을 수가 없는 것이다.
<br>

결국 위에서 언급한 것처럼, 여러 개의 프로세스 또는 스레드가 하나의 자원에 동시에 접근하게 된다면 각각의 프로세스에 원자성을 보장하여 이를 해결해야 한다!
<br>
이는 임계구역을 설정함으로서 해결할 수 있다.

#### 3. 임계구역에서 발생하는 문제를 해결하기 위한 방법으로는 '세마포어' 방법이 있다. 세마포어 방법이 무엇인지 서술하고, 세마포어 방법을 사용하면 어떤 장점이 있는지, 어떤 단점이 있는지 서술하시오.
세마포어 방법은 기존의 임계구역 문제 해결 방법들이 바쁜 대기를 사용하여 자원을 낭비하거나 알고리즘이 너무 복잡한 단점을 해결한 방법이다. 
<br>
세마포어 알고리즘에서는 프로세스에서 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 진입한다. 
<br>
이후 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다.
<br>
세마포어는 다음 프로세스에게 작업을 사용하라는 동기화 신호를 보낸다. 
<br>

<장점>
- 바쁜 대기를 하는 프로세스가 없다.
- 공유 자원이 여러 개일 때도 사용할 수 있다.

<단점>
- 잘못된 사용으로 인해 임계구역이 보호받지 못한다.
   - 프로세스가 세마포어를 사용하지 않고 바로 임계구역으로 들어간 경우
   - P()를 두 번 사용하여 wake_up() 신호가 발생하지 않은 경우
   - P() V()를 반대로 사용하여 상호배제가 보장되지 않은 경우

#### 4. 교착상태에는 총 4가지 필요조건이 존재한다. 각각의 필요조건이 무엇인지 서술하시오.
1) 상호 배제 : 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다.
2) 비선점 : 한 프로세스가 사용중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다.
3) 점유와 대기 : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태이어야 한다.
4) 원형 대기 : 점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 한다. 

#### 5. 교착 상태의 해결 방법 중에는 '교착 상태 검출과 회복'이 있다. 교착 상태를 검출하는 방법 2가지를 서술하고, 검출한 교착 상태를 어떻게 해결해야하는지 회복 방법을 서술하시오.

<교착 상태를 검출하는 방법>
1. 타임아웃 : 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하여 처리하는 방법
2. 자원 할당 그래프 : 단일 자원을 사용하는 경우 자원 할당 그래프에 사이클이 있으면 교착 상태이다. 하지만 다중 자원을 사용하는 경우 자원 할당 그래프에 사이클이 있다고 해서 모두 교착 상태라고 판단할 수 없다. 
- 장점 : 프로세스의 방식을 제한하지 않으면서 교착 상태를 정확하게 파악할 수 있음 
- 단점 : 자원 할당 그래프를 유지하고, 갱신하고, 사이클을 검사하는 추가 작업으로인해 오버헤드가 발생한다. 

<교착 상태 회복 방법>
<br>
교착 상태를 유발한 프로세스를 강제로 종료한다.
1. 교착 상태를 일으킨 모든 프로세스를 강제로 종료한다. 
2. 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료한다. 
- 우선순위가 낮은 프로세스 먼저 종료
- 작업 시간이 짧은 프로세스 먼저 종료
- 자원을 많이 사용하는 프로세스 먼저 종료 

강제 종료된 프로세스가 실행되기 전에 시스템 복구하는 일
- 체크 포인트를 만들어 가장 최근의 검사 시점으로 돌아가는 방식 (선택적 사용)

#### 6. 프로세스에 대한 다음와 같은 설명에서 틀린 것은?
정답 : ⑤
<br>
① 운영체제는 프로세스와 프로세스끼리 쉽게 데이터를 주고받을 수 있는 통신방법을 제공하는데, 이를 Inter Process Communication이라 한다.
<br>
② 파이프를 이용한 통신은 보통 부모-자식 간의 프로세스 통신에서 사용된다.
<br>
③ 소켓은 같은 컴퓨터 내의 프로세스끼리도 통신을 할 수 있게 한다.
<br>
④ 소켓은 파이프보다 초기화 할 내용도 많고 시스템 자원도 많이 사용한다.
<br>
**⑤ 공유메모리 방식은 OS로부터 고정적인 메모리 공간을 할당받지만, 수행되는 작업의 크기에 따라 변경될 수 있다.**
<br>
**→ 공유 메모리 방식은 os로부터 메모리를 할당 받을 때 고정적인 메모리 공간을 할당받으며, 이를 변하지 않는다.** 

#### 7. 프로세스에 대한 다음와 같은 설명에서 틀린 것을 모두 고르시오.
정답 : ③, ④
<br>
① 공유 자원이란 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다.
<br>
② 공유 자원의 접근 순서에 따라 실행 결과가 달라지는 영역을 임계구역(critical section)이라 한다.
<br>
**③ 한정 대기란 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다는 것을 의미한다.
<br>
→ 진행의 융통성이다. 
<br>
④ 진행의 융통성이란 어떠한 프로세스도 임계구역에 진입하지 못하여 무한 대기하지 않아야 한다는 것이다.
<br>
→ 한정 대기이다.** 
<br>
⑤ 상호배제란 한 프로세스가 임계구역으로 들어가면 다른 프로세스는 임계구역으로 들어갈 수 없다는 것을 의미한다.
<br>

#### 8. 임계구역 문제 해결 방법에 대한 설명으로 옳지 않은 것은?
정답 : ③
<br>
① 피터슨 알고리즘과 데커 알고리즘은 임계구역 문제 해결의 세 가지 조건을 모두 만족시키지만, 매우 복잡하다는 단점을 갖고 있다.
<br>
② 피터슨 알고리즘은 2개의 프로세스만 사용가능하다는 한계점을 갖고 있다.
<br>
**③ 진행의 융통성 문제를 해결하는 과정에서, 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 교착 상태라고 한다.
<br>
→ 진행의 융통성 문제를 해결하는 과정에서, 각각의 lock 값을 다르게 설정함으로써, 프로세스는 번갈아 실행되게 되지만, 한 프로세스가 두 번 연달아 임계구역에 진입할 수 없다. 즉, 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상이 발생하는데, 이는 **경직된 동기화**이다. 
<br>**
④ 임계구역 문제는 소프트웨어 방법으로 해결할 수 있지만, 하드웨어 방법으로도 해결할 수 있다.
<br>
⑤ 데커 알고리즘의 특징은 하드웨어의 도움 없이도 임계구역 문제를 해결할 수 있다는 것이 특징이다.
<br>

#### 9. 교착 상태에 대한 설명으로 옳지 않은 것은?
정답 : ②
<br>
① 2개 이상의 작업이 동시에 일어나는 경우 작업을 더 이상 진행하지 못하는 상태를 교착 상태라고 한다.
<br>
**② 아사 현상은 여러 프로세스가 작업을 동시에 진행하다보니 자연스럽게 발생하는 현상이지만, 교착상태는 잘못된 정책으로 특정 프로세스의 작업이 지연되는 문제이다.
<br>
→ 아사 현상과 교착 상태의 특징이 서로 뒤바뀌었다.**
<br>
③ 컴퓨터 시스템에서 교착 상태는 시스템 자원을 사용하거나 잠금을 사용할 때, 그리고 응용 프로그램에서 발생할 수 있다.
<br>
④ 자원 할당 그래프는 프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현한 것이다.
<br>
⑤ 자원 할당 그래프를 통해 어떤 프로세스에 어떤 자원이 할당되어 있고 어떤 프로세스가 자원을 기다리고 있는지 한 눈에 알 수 있다.
<br>

#### 10. 교착 상태 해결 방법에 대한 설명으로 옳지 않은 것은?
정답 : ②
<br>
① 교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화하는 방식을 교착 상태 예방이라고 한다.
<br>
**② 교착 상태 예방 방법 중 점유와 대기 예방은 자원을 바꾸어 교착 상태를 해결한다는데 의미가 있다.
<br>
→ 점유와 대기 예방은 자원이 아닌 프로세스의 자원 처리 방식을 바꾸어 교착 상태를 해결한다는데 의의가 있다.**
<br>
③ 상호 배제 예방과 비선점 예방은 자원에 대한 제약을 풀어버리는 방식이다.
<br>
④ 원형 대기 예방은 모든 자원을 할당받아야 실행할 수 있는 점유와 대기 예방보다 완화된 방법이다.
<br>
⑤ 점유와 대기 예방은 결국 일괄 작업 방식으로 동작한다는 한계점을 갖는다.
<br>

***
### 🔥5회차 해설
#### < 제작 문제 >
#### 1. 메모리에 대한 설명으로 옳지 않은 것은?
정답 : ⑤
<br>
① 프로그램이 실행되어 프로세스가 된다는 것은 저장장치에 있던 프로그램이 메모리로 올라온다는 것이다.
<br>
② CPU와 메모리의 속도 차이를 극복하기 위해 CPU 안에 캐시를 만들어 두고 일정 부분을 미리 가져와 작업하거나, 하드디스크나 SSD 같은 저장장치를 메인메모리의 보조저장장치로 활용한다.  
<br>
③ 메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가에 대한 문제이다.
<br>
④ 프로세스 입장에서는 메모리를 독차지하려고 하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고 싶어하는데, 이를 메모리 관리 이중성이라고 한다.
<br>
⑤ 현대의 메모리 관리 시스템은 프로세스와 메모리 관리자의 상충되는 요구사항을 **대부분 처리해주지만, 아직 완벽한 수준에 이르지는 않았다.**
<br>
**→ 현대 메모리 관리 시스템은 프로세스와 메모리 관리자의 상충되는 요구사항을 완벽히 처리한다.**

#### 2. 소스코드에 대한 설명으로 옳지 않은 것은?
정답 : ③
<br>
① 기계어와 어셈블리 언어를 저급언어라 하고, C언어와 자바 언어를 고급언어라 한다.
<br>
② 고급언어를 저급언어로 번역해주는 언어 번역 프로그램에는 컴파일러와 인터프리터가 있다.
<br>
③ 컴파일러는 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행하는 것으로 C언어, 자바, **자바스크립트**가 이 방식으로 프로그램을 실행한다.
<br>
**→ 자바스크립트는 인터프리터를 사용하는 언어이다.** 
<br>
④ 인터프리터는 소스코드를 한 행씩 번역하여 실행한다. 파이썬이 인터프리터를 이용하여 프로그램을 실행한다.
<br>
⑤ 컴파일러는 오류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제하는데, 이러한 과정을 통해서 만들어진 기계어 코드를 목적 코드라고 한다.
<br>

#### 3. 메모리 관리 작업에 대한 설명으로 옳지 않은 것은?
정답 : ③
<br>
① 메모리 관리 작업에는 fetch, placement, replacement가 있다.
<br>
② 실행할 프로세스와 데이터를 메모리로 가져오는 작업을 메모리 가져오기(fetch)라고 한다.
<br>
③ 메모리 배치는 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업으로, **이후 진행되는 메모리 자르기 작업이 매우 중요하다는 특징을 갖고 있다.**  
<br>
**→ 메모리를 자르는 작업은 배치 전에 시행되는 작업이다. 같은 크기로 자르느냐(페이징), 프로세스의 크기에 맞게 자르느냐(세그먼테이션)에 따라 메모리 관리 복잡성이 달라지기 때문이다.** 
<br>
④ 메모리를 같은 크기로 자르는 것을 페이징이라하고, 프로세스의 크기에 맞게 자르는 것을 세그먼테이션이라 한다.   
<br>
⑤ 배치 정책은 페이징과 세그먼테이션의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만드는 것이다.
<br>

#### 4. 메모리 주소에 대한 설명으로 옳지 않은 것은?
정답 : ⑤
<br>
① 컴퓨터에는 메모리가 설치되고 각 메모리에는 주소 공간이 있는데, 이를 물리 주소 공간이라고 한다.
<br>
② 사용자 프로세스는 운영체제 영역을 피하여 메모리에 적재된다는 특징을 갖고 있다.
<br>
③ 사용자 프로세스가 운영체제의 크기에 따라 매번 적재되는 일이 발생하면 번거로운데, 이를 사용자 프로세스를 메모리의 최상위부터 사용함으로써 개선하였다.
<br>
④ 물리 주소는 메모리 주소 레지스터가 사용하는 주소로, 컴퓨터에 꽂힌 실제 램 메모리의 주소를 의미한다.
<br>
**⑤ 프로그램이 실행될 때마다 실제 램에 있는 물리 주소 때문에, 논리 주소는 매번 바뀐다는 특징을 갖고 있다.
<br>
→ 프로그램이 실행될 때마다 실행되는 물리주소는 매번 바뀐다는 특징을 갖는다. (논리 주소는 그대로이다. 시작되는 물리 주소가 바뀌어 논리 주소가 물리 주소로 바뀔 때 물리 주소가 바뀌는 것이다.)**

#### 5. 단일 프로그래밍 환경의 메모리 할당에 대해 옳지 않은 것은?
정답 : ③
<br>
① 프로그램의 크기가 실제 메모리 (물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법을 메모리 오버레이라고 한다.
<br>
② 메모리 오버레이에서 하나의 큰 프로세스는 각각의 모듈 형태로 분리되어 있다가 프로그램이 실행되면 필요한 것만 메모리에 올라와 실행된다.
<br>
**③ 메모리 오버레이에서 어떤 모듈을 가져오거나 내보낼지는 메모리 관리자가 결정한다.
<br>
→ 메모리 오버레이에서 어떤 모듈을 가져오거나 내보낼지는 프로그램 카운터 (PC)가 결정한다.**
<br>
④ 메모리가 모자라서 쫓겨난 프로세스를 저장장치의 특별한 공간에 모아두는데, 이 영역을 스왑 영역이라고 한다.
<br>
⑤ 메모리 오버레이에서 스왑영역을 이용하면 사용자는 실제 메모리와 스왑 영역의 크기를 합쳐서 전체 메모리의 크기로 인식하고 사용할 수 있다.
<br>

#### 6. 다중 프로그래밍 환경의 메모리 할당에 대한 설명으로 옳지 않은 것은?
정답 : ⑤
<br>
① 메모리에 여러 개의 프로세스를 배치하는 방법은 크게 가변 분할 방식과 고정 분할 방식으로 나뉜다.
<br>
② 가변 분할 방식에서는 연속 메모리 할당을 사용하고, 고정 분할 방식에서는 비연속 메모리 할당을 사용한다.
<br>
③ 가변 분할 방식은 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치할 수 있다.
<br>
④ 고정 분할 방식은 메모리를 일정한 크기로 나누기 때문에 메모리 관리가 편하다는 장점이 있다.
<br>
**⑤ 고정 분할 방식은 하나의 프로세스가 여러 곳으로 나뉠 수 있어 서로 다른 곳에 배치될 수가 있어 실행에 어려움을 겪는 경우도 있다.
<br>
→ 고정 분할 방식은 하나의 프로세스가 여러 곳으로 나뉠 수 있지만, 스왑 영역이 있기 때문에 실행에는 전혀 문제가 없다.**

#### 7. 가변 분할 방식의 메모리 관리에 대한 설명으로 옳지 않은 것은?
정답 : ③
<br>
① 가변 분할 방식은 프로세스의 크기에 맞춰 메모리를 할당하는 방법으로 세그먼테이션 메모리 관리 기법이라고 한다.
<br>
② 가변 분할 방식에서 외부 단편화 문제가 발생하는데, 외부 단편화란 조각이 프로세스의 바깥쪽에 위치하기 때문에 만들어진 이름이다.
<br>
**③ 가변 분할 방식에서 외부 단편화 문제를 해결하기 위한 방법으로 선처리 방법인 조각 모음과 후처리 방법인 메모리 배치 방식이 있다.
<br>
→ 외부 단편화 문제를 해결하기 위한 방법으로 선처리 방법인 메모리 배치 방식과 후처리 방법인 조각 모음이 있다.** 
<br>
④ 외부 단편화 문제를 해결하기 위한 방법인 메모리 배치 방식에는 최초 배치, 최적 배치, 최악 배치, 그리고 버디 시스템이 있다.
<br>
⑤ 조각 모음에서 조각이 모이면 프로세스를 적당한 위치로 이동시키는데, 이때 프로세스의 논리 주소 값을 변경한다.
<br>

#### 8. 고정 분할 방식의 메모리 관리에 대한 설명으로 옳지 않은 것은?
정답 : ⑤
<br>
① 고정 분할 방식을 사용하여 물리 메모리를 나누는 방식을 페이징 메모리 관리 기법이라 한다.
<br>
② 현대의 메모리 관리는 페이징을 기본으로 한다.
<br>
③ 고정 분할 방식은 일정하게 나뉜 메모리의 크기보다 작은 프로세스가 배치될 경우 공간이 낭비된다는 점이다.
<br>
④ 내부 단편화는 각 메모리 조각에 프로세스를 배치하고 공간이 남는 것을 의미한다.
<br>
**⑤ 가변 분할 방식의 외부 단편화는 조각 모음으로 조정했으나 고정 분할 방식에서는 내부 단편화를 해결하기 위해 조각 모음을 할 수 없다. 하지만 고정 분할 방식에서는 남는 공간을 다른 프로세스에게 배정해줄 수 있다는 점에서 차이를 갖는다.
<br>
→ 고정 분할 방식에서는 남는 공간을 다른 프로세스에게 배정해줄 수 없다.** 

#### 9. 버디 시스템에 대한 설명으로 옳지 않은 것은?
정답 : ④
<br>
① 버디 시스템은 가변 분할 방식과 고정 분할 방식의 특징을 모두 가지고 있다.
<br>
② 가변 분할 방식에 비해 버디 시스템에서 효과적으로 공간을 관리할 수 있는 이유는 비슷한 크기의 덩어리가 서로 모여있어 통합하기 쉽기 때문이다.
<br>
③ 버디 시스템은 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고, 메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생한다.
<br>
**④ 효율적인 공간 관리 측면을 보면 고정 분할 방식이 버디 시스템보다 효율적이기 때문에 버디 시스템보다 고정 분할 방식을 더 많이 사용한다.
<br>
→ 효율적인 공간 관리 측면을 보면 고정 분할 방식과 버디 시스템은 비슷한 수준이다.** 
<br>
⑤ 메모리 관리 측면에서 공간을 1/2로 나누어가며 메모리를 배분하는 버디 시스템보다 모든 공간을 똑같은 크기로 나누는 고정 분할 방식이 더 단순하다.
<br>

#### 10. 분할 컴파일과 메모리 관리에 대한 설명으로 옳지 않은 것은?
정답 : ③
<br>
① 여러 개의 소스코드 파일을 사용하여 하나의 실행 파일을 만드는 것을 다중 소스코드라 한다.
<br>
② 여러 개의 소스코드를 각각 컴파일하여 하나의 실행 파일로 만드는 것을 분할 컴파일이라 한다.
<br>
**③ 분할 컴파일의 경우 자신의 코드를 컴파일하여 목적 코드를 만들고 오류 검사를 하여 연결 단계로 목적 코드를 넘겨준다.
<br>
→ 분할 컴파일의 경우 자신의 코드를 컴파일하여 목적 코드를 만들고 오류검사 없이 연결 단계로 넘어간다. (목적 코드는 오류 검사가 이미 끝난 파일이기 때문이다.)
<br>**
④ 컴파일러는 프로그래머가 지정한 자료형의 크기에 따라 메모리를 확보하고 그곳에 적당한 값을 집어넣는다.
<br>
⑤ 컴파일러는 변수를 사용할 때마다 사용 범위를 넣는지 점검한다.
<br>








